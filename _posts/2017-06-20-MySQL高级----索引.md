## 索引简介

MySQL 官方对索引的定义：索引（Index）是帮助MySQL高级获取数据的数据结构。
可以得到索引的本质：“索引是数据结构”，可以简单的理解为：<font color="#FF0000"> “排好序的快速查找数据结构”</font>

## 索引的优劣势

### 优势：

> * 提高数据检索的效率，降低数据的IO成本。
> * 通过索引列对数据进行排序，降低数据排序成本，降低了CPU的消耗。

### 劣势：

> * 索引提高了查询速度，同时降低了更新表的速度。如对表进行（INSTER、UODATE和DELETE），因为更新表时，MySQL不仅要保存数据，还要保存下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息
    
## 索引分类

> * 单值索引 --> 即一个索引只包含单个列，一个表可以有多个单列索引
> * 唯一索引 --> 索引列的值必须唯一，但允许有空值
> * 复合索引 -->

## 基本语法
> * 创建

```sql
alter table table_name add PRIMARY index_name (column_list) ;#该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL

alter table table_name add UNIQUE index_name (column_list) ;#这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）

alter table table_name add index index_name (column_list) ;#添加普通索引，索引值可出现多次

alter table table_name add FULLTEXT index_name (column_list) ;#该语句指定了索引为FULLTEXT，用于全文索引
```

> * 删除

```sql
drop index index_name on table_name ;
alter table table_name drop index index_name ;
alter table table_name drop primary key ;
```

> * 查看

```sql
show index from table_name
```

## 索引结构
> * BTree索引 *
> * Hash索引
> * full-text索引
> * R-Tree索引

## 那些情况需要建索引
> * 主键自动建立唯一索引
> * 频繁作为查询条件的字段应该创建索引
> * 查询中与其他表关联的字段，外键关系建立索引
> * 频繁更新的字段不时候创建索引
> * where条件里用不到的字段不创建索引
> * 单键/组合索引的选择问题，who？（在高并发下倾向创建组合索引）
> * 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
> * 查询中统计或者分组字段

## 那些情况不建索引
> * 表记录太少
> * 经常增删改的表
> * 数据重复切分布平均的表字段，因此应该只为最经常查询和经常排序的数据列简历索引。注意，如果某个数据列包含许多重复的内容，为它简历索引就没有太大的实际效果（如：性别）

## 性能分析
### MySQL Query Optimizer
1、MySQL中有专门负责优化SELECT语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得DBA认为是最优的，这部分最耗费时间）
2、当客户端向MySQL请求一条Query，命令解析器模块完成请求分类，区别出是SELECT并转发给MySQL Query Optimizer时，MySQL Query Optimizer首先会对整条Query进行优化，处理掉一些常量表达式的预算等。然后分析Query中的Hint信息（如果有），看显示Hint信息是否可以完全确定该Query的执行计划。如果没有Hint或Hint信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据Query进行写相应的计算分析，然后再得出最后的执行计划
### MySQL常见瓶颈
CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据的时候，
IO:	磁盘I/O瓶颈发送在装入数据远大于内存容量的时候
	服务器硬件的性能瓶颈：top，free，iostat和vmstat来查看系统的性能状态
### Explain
使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈

能干嘛：

-->表的读取顺序

-->数据读取操作的操作类型

-->那些索引可以使用

-->那些索引被实际使用

-->表之间的引用

-->每张表有多少行被优化器查询


#### 执行计划包含的信息
![img](http://qiniu.wsxxg.cn/QQ%E5%9B%BE%E7%89%8720170620153219.png)
> * id --> select 查询的序列号，包含一组数字，表示查询中执行select子句或者操作表的顺序

三种情况

① id相同，执行顺序由上至下

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170620154016.png)

②id不同，如果是字查询，id的序号会递增，id越大优先级越高，越先被执行

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170620154226.png)

③id相同不同，同时存在

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170620154823.png)

> * select_type 查询类型，主要是用于区别普通查询、联合查询、子查询等复杂的查询

① SIMPLE  简单的select查询，查询中不包含子查询或者UNION

② PRIMARY  查询中若包含任何复杂的子部分，最外层查询被标记为

③ SUBQUERY  在select或where中包含了子查询

④ DERIVED  在from列表中包含的子查询被标记为DERIVED（衍生）MySQL会递归执行这些子查询，把结果放在临时表里

⑤ UNION  若第二个select出现在union之后，则被标记为union；若union包含在from子句查询中，外层select将被标记为：DERIVED

⑥ UNION RESULT  从union表中获取结果的select

> * table 显示这一行的数据是关于那张表的

> * type 访问类型排列

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170620160923.png)

①system 表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不记

②const 表示通过索引一次就找到了，const用于比较primarykey或者unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量

③eq_ref 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或者唯一索引扫描

④ref 非唯一性索引扫描，返回匹配某个单独的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而他可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体

⑤range 值检索给定范围的行，使用一个索引来选择行，key列显示使用了那个索引，一般就是在你的where语句中出现了between、<、>、in等的查询，这种范围扫描索引比全表扫描要好，因为他只需要开始于索引的某一点，而结束语另一点，不用扫码全部索引

⑥Index Full Index Scan，index与All区别为index类型只遍历索引树。这通常比All快，因为索引文件通常比数据文件小。（也就是说虽然All和Index都是读全表，但是Index是从索引中读取，而All是从硬盘中读的）

⑦All Full Table Scan，建遍历全表以找到匹配的行

<font color="#FF0000">备注：一般来说，得保证查询至少达到range级别，最好能达到ref</font>

> * possible_keys 显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，<font color="#FF0000">但不一定被查询实际使用</font>

> * key 实际使用的索引。如果为NULL，则没有使用索引。查询中如使用了覆盖索引，则该索引仅出现在key列表中

> * key_len 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。key_len显示的值为索引字段的最大可能长度，<font color="#FF0000">并非实际使用长度</font>，即ken_len是根据表定义计算而得，不是通过表内检索出的

> * ref 显示索引的那一列被使用了，如果可能的话，是一个常数。那些列或者常量被用于查找索引列上的值

> * rows 根据表统计信息及索引选用情况，大致估算出找到所需要的记录所需要读取的行数

> * Extra 包含不合适在其他列中显示但十分重要的额外信息

① Using filesort 说明MySQL会对数据使用一个外部的索引排序。而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”

② Using temporary 使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序order by 和分组查询group by

③ Using Index 表示响应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错！如果同事出现using where 表示索引被用来执行索引键值的查找

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170621171826.png)

覆盖索引Covering Index

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170621172258.png)

④ Using where 表明使用了where过滤

⑤ Using join buffer  表名使用了连接缓存

⑥ impossible where where子句的值总是false，不能用来获取任何元组

explain select * from t1 where name ='a' and name ='b';

⑦ select tables optimized away 在没有group by子句的情况下，基业索引优化min/max操作或者对应MyISAM存储引擎优化COUNT（*）操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化

⑧ dictinct 优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作

### 热身Case

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170621173615.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170621173713.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170621174022.png)

## 索引优化

> * 索引分析

①单表

--建表sql

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170621174815.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170621175542.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623141930.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623142346.png)

--案例

②两表

--建表sql

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623142620.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623143113.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623144243.png)

--案例

③三表

--建表sql

![img](http://qiniu.wsxxg.cn/QQ%E5%9B%BE%E7%89%8720170623144501.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623150943.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623151341.png)

--案例

> * 索引失效（应该避免）

--建表

![img](http://qiniu.wsxxg.cn/QQ%E5%9B%BE%E7%89%8720170616141225.png)

--案例

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623152851.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623153135.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623153619.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623154017.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623154311.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623154928.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623155206.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623155340.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623160106.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623160235.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623161038.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623162451.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623162708.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623162828.png)

创建索引

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623163307.png)

创建索引后，索引失效

http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623163307.png

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623163832.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623164034.png)

小总结

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623170556.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623170854.png)

--面试题讲解

题目SQL

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623164740.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623164954.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623165202.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623165324.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623165546.png)

定值、范围还是排序，一般order by是给个范围

group by基本上都需要进行排序，会有临时表产生

> * 一般性建议

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623170014.png)

## 查询截取分析

### 查询优化

> * <font color="#FF0000">永远小标驱动大表</font>，类似嵌套循环Nesred Lopp

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623171740.png)

![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170623172224.png)

> * order by关键字优化

① order by 子句，尽量使用Index方式排序，避免使用FileSort方式哦爱心

②尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀

③如果不在索引列上，filesort有两种算法，MySQL就要启动双路排序和单路排序

④优化策略

⑤小总结


### 慢查询日志

### 批量数据脚本

### Show profile

### 全局查询日志


