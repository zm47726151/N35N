## 索引简介
MySQL 官方对索引的定义：索引（Index）是帮助MySQL高级获取数据的数据结构。
可以得到索引的本质：“索引是数据结构”，可以简单的理解为：<font color="#FF0000"> “排好序的快速查找数据结构”</font>

## 索引的优劣势
### 优势：
> * 提高数据检索的效率，降低数据的IO成本。
> * 通过索引列对数据进行排序，降低数据排序成本，降低了CPU的消耗。

### 劣势：
> * 索引提高了查询速度，同时降低了更新表的速度。如对表进行（INSTER、UODATE和DELETE），因为更新表时，MySQL不仅要保存数据，还要保存下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息
    
## 索引分类
> * 单值索引 --> 即一个索引只包含单个列，一个表可以有多个单列索引
> * 唯一索引 --> 索引列的值必须唯一，但允许有空值
> * 复合索引 -->

## 基本语法
> * 创建
```sql
alter table table_name add PRIMARY index_name (column_list) ;#该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL

alter table table_name add UNIQUE index_name (column_list) ;#这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）

alter table table_name add index index_name (column_list) ;#添加普通索引，索引值可出现多次

alter table table_name add FULLTEXT index_name (column_list) ;#该语句指定了索引为FULLTEXT，用于全文索引
```

> * 删除
```sql
drop index index_name on table_name ;
alter table table_name drop index index_name ;
alter table table_name drop primary key ;
```

> * 查看
```sql
show index from table_name
```

## 索引结构
> * BTree索引 *
> * Hash索引
> * full-text索引
> * R-Tree索引

## 那些情况需要建索引
> * 主键自动建立唯一索引
> * 频繁作为查询条件的字段应该创建索引
> * 查询中与其他表关联的字段，外键关系建立索引
> * 频繁更新的字段不时候创建索引
> * where条件里用不到的字段不创建索引
> * 单键/组合索引的选择问题，who？（在高并发下倾向创建组合索引）
> * 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
> * 查询中统计或者分组字段

## 那些情况不建索引
> * 表记录太少
> * 经常增删改的表
> * 数据重复切分布平均的表字段，因此应该只为最经常查询和经常排序的数据列简历索引。注意，如果某个数据列包含许多重复的内容，为它简历索引就没有太大的实际效果（如：性别）

## 性能分析
### MySQL Query Optimizer
![img](http://qiniu.wsxxg.cn/QQ%E5%9B%BE%E7%89%8720170620151921.png)
### MySQL常见瓶颈
![img](http://qiniu.wsxxg.cn/QQ%E5%9B%BE%E7%89%8720170620152149.png)
### Explain
![img](http://qiniu.wsxxg.cn/QQ%E5%9B%BE%E7%89%8720170620152409.png)
![img](http://qiniu.wsxxg.cn/QQ%E5%9B%BE%E7%89%8720170620152845.png)

#### 执行计划包含的信息
![img](http://qiniu.wsxxg.cn/QQ%E5%9B%BE%E7%89%8720170620153219.png)
> * id --> select 查询的序列号，包含一组数字，表示查询中执行select子句或者操作表的顺
三种情况
① id相同，执行顺序由上至下
![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170620154016.png)
②id不同，如果是字查询，id的序号会递增，id越大优先级越高，越先被执行
![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170620154226.png)
③id相同不同，同时存在
![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170620154823.png)
> * select_type 查询类型，主要是用于区别普通查询、联合查询、子查询等复杂的查询
① SIMPLE  简单的select查询，查询中不包含子查询或者UNION
② PRIMARY  查询中若包含任何复杂的子部分，最外层查询被标记为
③ SUBQUERY  在select或where中包含了子查询
④ DERIVED  在from列表中包含的子查询被标记为DERIVED（衍生）MySQL会递归执行这些子查询，把结果放在临时表里
⑤ UNION  若第二个select出现在union之后，则被标记为union；若union包含在from子句查询中，外层select将被标记为：DERIVED
⑥ UNION RESULT  从union表中获取结果的select
> * table 显示这一行的数据是关于那张表的
> * type 访问类型排列
![img](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170620160923.png)
①system 表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不记
②const 表示通过索引一次就找到了，const用于比较primarykey或者unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量
③eq_ref 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或者唯一索引扫描
④ref 非唯一性索引扫描，返回匹配某个单独的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而他可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体
⑤range 值检索给定范围的行，使用一个索引来选择行，key列显示使用了那个索引，一般就是在你的where语句中出现了between、<、>、in等的查询，这种范围扫描索引比全表扫描要好，因为他只需要开始于索引的某一点，而结束语另一点，不用扫码全部索引
⑥Index Full Index Scan，index与All区别为index类型只遍历索引树。这通常比All快，因为索引文件通常比数据文件小。（也就是说虽然All和Index都是读全表，但是Index是从索引中读取，而All是从硬盘中读的）
⑦All Full Table Scan，建遍历全表以找到匹配的行
<font color="#FF0000">备注：一般来说，得保证查询至少达到range级别，最好能达到ref</font>
> * possible_keys
> * key
> * key_len
> * ref
> * rows