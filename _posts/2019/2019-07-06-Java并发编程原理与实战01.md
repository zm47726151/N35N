# Java并发编程原理与实战 01

## 1.1 线程的状态

![线程状态](http://qiniu.wsxxg.cn/20190711152056.png)

## 1.2 线程的创建与运行


### 1.2.1 继承 Thread 类

```java

/**
 * 继承Thread类
 */
public class MyThread extends Thread {

    @Override
    public void run() {
        System.out.println("I am a chlid thread !");
    }

    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
        System.out.println("I am main thread !");
    }
}


```


### 1.2.2 实现 Runnable 类

```java

/**
 * 实现Runnable接口
 */
public class RunableTask implements Runnable {

    @Override
    public void run() {
        System.out.println("I am a child " + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        RunableTask runableTask = new RunableTask();
        new Thread(runableTask).start();
        new Thread(runableTask).start();
        System.out.println("I am main thread !");
    }
}

```

### 1.2.3 带返回值的线程

```java

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

/**
 * 带返回值的线程
 */
public class CallerTask implements Callable<String> {

    @Override
    public String call() throws Exception {
        return "I am a child thread  ";
    }

    public static void main(String[] args) {
        CallerTask callerTask = new CallerTask();

        FutureTask<String> futureTask = new FutureTask<>(callerTask);
        new Thread(futureTask).start();
        String result = null;
        try {
            result = futureTask.get();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

        System.out.println(result);
    }
}

```

### 1.2.4 匿名内部类的方式

```java

/**
 * 匿名内部类实现
 */
public class AnonymousTask {
    public static void main(String[] args) {
        // 通过Thread创建匿名线程
        new Thread(){
            @Override
            public void run() {
                System.out.println("I am a child thread by Thread!");
            }
        }.start();

        // 通过Runnable创建匿名线程
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("I am a child thread by Runnable !");
            }
        }).start();


        // 通过Thread 和 Runnable创建匿名线程，结果为Thread
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("I am a child thread by Runnable !");
            }
        }){
            @Override
            public void run() {
                System.out.println("I am a child thread by Thread!");
            }
        }.start();

    }
}

```

### 1.2.5 定时器（quartz）

```java

/**
 * 定时器
 */
public class TimerDemo {
    public static void main(String[] args) {
        Timer timer = new Timer();
        TimerTask timerTask = new TimerTask() {
            @Override
            public void run() {
                System.out.println("I am a Timer");
            }
        };
        timer.schedule(timerTask,0,5000);
    }
}

```

### 1.2.6 线程池的实现

```java

import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

/**
 * 线程池实现
 */
public class ExecutorDemo {
    public static void main(String[] args) {
        // 固定容量的线程池
        Executor threadPool = Executors.newFixedThreadPool(10);

        for (int i= 0 ; i<100;i++){
            threadPool.execute(new Runnable() {
                @Override
                public void run() {
                    System.out.println("I am a "+ Thread.currentThread().getName());
                }
            });
        }
    }
}

```

### 1.2.7 Lambda表达式实现

```java

/**
 * Lambda 表达式
 */
public class LambdaDemo {
    public static void main(String[] args) {
        List<Integer> list = Arrays.asList(10,20,30,40);
        System.out.println(add(list));

    }

    public static int add(List<Integer> values){
        // 查看是否是并行
//        values.parallelStream().forEach(System.out :: println);
        return values.parallelStream().mapToInt(i -> i).sum();
    }

}

```

## 1.3 线程通知与等待

## 1.4

## 1.5

## 1.6

## 1.7

## 1.8

## 1.9

## 1.10

## 1.11