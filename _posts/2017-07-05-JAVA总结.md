# JAVA 基础

### Java 中的几种基本数据类型是什么，各自占用多少字节。
![基本数据类型](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170705135346.png)

### String 类能被继承吗，为什么。
因为Sting是这样定义的：public final class String extends Object，里边有final关键字，所以不能被继承。

什么样的类不能被继承？

　一，在Java中，只要是被定义为final的类，也可以说是被final修饰的类，就是不能被继承的。
　二，final是java中的一个关键字，可以用来修饰变量、方法和类。用关键词final修饰的域成为最终域。用关键词final修饰的变量一旦赋值，就不能改变，也称为修饰的标识为常量。如果一个类的域被关键字final所修饰，它的取值在程序的整个执行过程中将不会改变。
　三，假如说整个类都是final，就表明自己不希望从这个类继承，或者不答应其他任何人采取这种操作。换言之，出于这样或那样的原因，我们的类肯定不需要进行任何改变；或者出于安全方面的理由，我们不希望进行子类化（子类处理）。
　
### String，Stringbuffer，StringBuilder的区别。

String和StringBuffer，它们可以储存和操作字符串。
String类提供了数值不可改变的字符串。
StringBuffer类提供的字符串进行修改。字符数据要改变的时候你就可以使用StringBuffer。
String实现了equals方法，new String(“abc”).equals(new String(“abc”)的结果为true
而StringBuffer没有实现equals方法，
所以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。
String覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法，
所以，将StringBuffer对象存储进Java集合类中时会出现问题。

###  ArrayList 和 LinkedList 有什么区别。
ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。

LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。
### 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当 new 的时候，他们的执行顺序。
![Java类加载及实例化的调用顺序](http://qiniu.wsxxg.cn/452847-20160527221410288-2119099273.png)


### 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。
最常用的Map实现类有:HashMap，ConcurrentHashMap（jdk1.8），LinkedHashMap，TreeMap,HashTable；
其中最频繁的是HashMap和ConcurrentHashMap，他们的主要区别是HashMap是非线程安全的。ConcurrentHashMap是线程安全的。
并发下可以使用ConcurrentHashMap和HashTable，他们的主要区别是：
1.ConcurrentHashMap的hash计算公式：(key.hascode()^ (key.hascode()>>> 16)) & 0x7FFFFFFF
   HashTable的hash计算公式：key.hascode()& 0x7FFFFFFF
2.HashTable存储方式都是链表+数组，数组里面放的是当前hash的第一个数据，链表里面放的是hash冲突的数据
 ConcurrentHashMap是数组+链表+红黑树
3.默认容量都是16，负载因子是0.75。就是当hashmap填充了75%的busket是就会扩容，最小的可能性是（16*0.75），一般为原内存的2倍
4.线程安全的保证：HashTable是在每个操作方法上面加了synchronized来达到线程安全，ConcurrentHashMap线程是使用CAS(compore and swap)来保证线程安全的

### JAVA8的 ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。
jdk8 放弃了分段锁而是用了Node锁，减低锁的粒度，提高性能，并使用CAS操作来确保Node的一些操作的原子性，取代了锁。
但是ConcurrentHashMap的一些操作使用了synchronized锁，而不是ReentrantLock,虽然说jdk8的synchronized的性能进行了优化，但是我觉得还是使用ReentrantLock锁能更多的提高性能
### 有没有有顺序的Map 实现类，如果有，他们是怎么保证有序的。
顺序的 Map 实现类:LinkedHashMap,TreeMap
LinkedHashMap 是基于元素进入集合的顺序或者被访问的先后顺序排序，TreeMap 则是基于元素的固有顺序 (由 Comparator 或者 Comparable 确定)。

###  抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。

1.抽象类可以有自己的实现方法，接口在jdk8以后也可以有自己的实现方法（default）
2.抽象类的抽象方法是由非抽象类的子类实现，接口的抽象方法有接口的实现类实现
3.接口不能有私有的方法跟对象，抽象类可以有自己的私有的方法跟对象
类不可以继承多个类，接口可以继承多个接口，类可以实现多个接口


### 讲讲你理解的 nio。他和 bio 的区别是啥，谈谈 reactor 模型。 
BIO：同步阻塞式IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
NIO：同步非阻塞式IO，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。
reactor模型：反应器模式（事件驱动模式）：当一个主体发生改变时，所有的属体都得到通知，类似于观察者模式。

### 反射中，Class.forName 和 ClassLoader 区别。
class.forName()除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。
classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。

### 反射的原理，反射创建类实例的三种方式是什么。
反射的原理：如果知道一个类的名称/或者它的一个实例对象， 就能把这个类的所有方法和变量的信息(方法名，变量名，方法，修饰符，类型，方法参数等等所有信息)找出来。
反射创建类实例的三种方式：
1.Class.forName("com.A");
2.new A().getClass();
3.A.class;
 

### 描述动态代理的几种实现方式，分别说出相应的优缺点。（动态代理与cglib 实现的区别。）
动态代理有两种实现方式，分别是：jdk动态代理和cglib动态代理
jdk动态代理的前提是目标类必须实现一个接口，代理对象跟目标类实现一个接口，从而避过虚拟机的校验。
cglib动态代理是继承并重写目标类，所以目标类和方法不能被声明成final。
 

### 为什么CGlib 方式可以对接口实现代理。
 cglib动态代理是继承并重写目标类，所以目标类和方法不能被声明成final。而接口是可以被继承的。


### final的用途。
final类不能被继承，没有子类，final类中的方法默认是final的。  
final方法不能被子类的方法覆盖，但可以被继承。  
final成员变量表示常量，只能被赋值一次，赋值后值不再改变。  
final不能用于修饰构造方法  
### 出三种单例模式实现。
```java
/**
 * 单例模式
 */
public class Singleton {

    /**
     * 饿汉式 单例模式
     * 类在加载时就实例化，
     * 提供一个公共的方法获取实例化的类
     * <p>
     * 优点：线程安全
     * <p>
     * 缺点：类被加载时就实例化，
     * 有可能在整个代码周期都没有使用
     * 且不会被回收，会一直存在
     */
    private static class 饿汉式 {
        private static 饿汉式 饿汉式 = new 饿汉式();

        private 饿汉式() {

        }

        static 饿汉式 get饿汉式() {
            return 饿汉式;
        }
    }


    /**
     * 懒汉式 单例模式
     * 只有在真正使用的时候，才实例化
     * <p>
     * 优点：只有在真正使用的时候才实例化
     * <p>
     * 缺点：线程不安全
     */
    private static class 懒汉式 {
        private static 懒汉式 懒汉式;

        private 懒汉式() {

        }

        static synchronized 懒汉式 get懒汉式() {
            if (null == 懒汉式) {
                懒汉式 = new 懒汉式();
            }
            return 懒汉式;
        }
    }

    /**
     * 枚举式 单例模式
     * 跟 饿汉式 一样
     */

    private enum 枚举式 {
        枚举式;

        public 枚举式 get枚举式() {
            return 枚举式;
        }
    }

    public static void main(String[] args) {
        Singleton.懒汉式 懒汉式 = Singleton.懒汉式.get懒汉式();
        if (懒汉式 == Singleton.懒汉式.get懒汉式()) {
            System.out.println("懒汉式--单例生效");
        }

        Singleton.饿汉式 饿汉式 = Singleton.饿汉式.get饿汉式();


        if (饿汉式 == Singleton.饿汉式.get饿汉式()) {
            System.out.println("饿汉式--单例生效");
        }

        if (枚举式.枚举式.get枚举式() == 枚举式.枚举式.get枚举式()) {
            System.out.println("枚举式--单例生效");
        }
    }
}

```

### 如何在父类中为子类自动完成所有的 hashcode 和 equals 实现？这么做有何优劣。
父类的equals不一定满足子类的equals需求。比如所有的对象都继承Object，默认使用的是Object的equals方法，在比较两个对象的时候，是看他们是否指向同一个地址。
但是我们的需求是对象的某个属性相同，就相等了，而默认的equals方法满足不了当前的需求，所以我们要重写equals方法。
如果重写了equals 方法就必须重写hashcode方法，否则就会降低map等集合的索引速度。
 

### 请结合 OO 设计理念，谈谈访问修饰符 public、private、protected、default 在应用设计中的作用。
![OO 设计理念](http://qiniu.wsxxg.cn/QQ%E6%88%AA%E5%9B%BE20170705173544.png)


### 深拷贝和浅拷贝区别。
浅拷贝只拷贝指针，深拷贝就是拷贝他的值，重新生成的对像。
 

### 数组和链表数据结构描述，各自的时间复杂度。
数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。
链表恰好相反，链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。
访问数组中第 n 个数据的时间花费是 O(1) 但是要在数组中查找一个指定的数据则是 O(N) 。当向数组中插入或者删除数据的时候，最好的情况是在数组的末尾进行操作，时间复杂度是 O(1) ，但是最坏情况是插入或者删除第一个数据，时间复杂度是 O(N) 。在数组的任意位置插入或者删除数据的时候，后面的数据全部需要移动，移动的数据还是和数据个数有关所以总体的时间复杂度仍然是 O(N) 。 

 在链表中查找第 n 个数据以及查找指定的数据的时间复杂度是 O(N) ，但是插入和删除数据的时间复杂度是 O(1)
 

### error 和 exception 的区别，CheckedException，RuntimeException 的区别。
Error（错误）表示系统级的错误和程序不必处理的异常，是java运行环境中的内部错误或者硬件问题。比如：内存资源不足等。对于这种错误，程序基本无能为力，除了退出运行外别无选择，它是由Java虚拟机抛出的。

Exception（违例）表示需要捕捉或者需要程序进行处理的异常，它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的。
Exception又分为运行时异常，受检查异常。
       RuntimeException(运行时异常)，表示无法让程序恢复的异常，导致的原因通常是因为执行了错误的操作，建议终止程序，因此，编译器不检查这些异常。
       CheckedException(受检查异常)，是表示程序可以处理的异常，也即表示程序可以修复（由程序自己接受异常并且做出处理）， 所以称之为受检查异常。
 

### 请列出 5 个运行时异常。
NullPointerException
IndexOutOfBoundsException
ClassCastException
ArrayStoreException
BufferOverflowException

### 在自己的代码中，如果创建一个 java.lang.String 对象，这个对象是否可以被类加载器加载？为什么。
不可以，双亲委派模式会保证父类加载器先加载类，就是BootStrap（启动类）加载器加载jdk里面的java.lang.String类，而自定义的java.lang.String类永远不会被加载到

### 说一说你对 java.lang.Object 对象中 hashCode 和 equals 方法的理解。在什么场景下需要重新实现这两个方法。
父类的equals不一定满足子类的equals需求。比如所有的对象都继承Object，默认使用的是Object的equals方法，在比较两个对象的时候，是看他们是否指向同一个地址。
但是我们的需求是对象的某个属性相同，就相等了，而默认的equals方法满足不了当前的需求，所以我们要重写equals方法。
如果重写了equals 方法就必须重写hashcode方法，否则就会降低map等集合的索引速度。
 
### 在 jdk1.5 中，引入了泛型，泛型的存在是用来解决什么问题。
泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。

### 这样的 a.hashcode() 有什么用，与 a.equals(b)有什么关系。
1、equals方法用于比较对象的内容是否相等（覆盖以后）  
2、hashcode方法只有在集合中用到  
3、当覆盖了equals方法时，比较对象是否相等将通过覆盖后的equals方法进行比较（判断对象的内容是否相等）。  
4、将对象放入到集合中时，首先判断要放入对象的hashcode值与集合中的任意一个元素的hashcode值是否相等，如果不相等直接将该对象放入集合中。  
如果hashcode值相等，然后再通过equals方法判断要放入对象与集合中的任意一个对象是否相等，如果equals判断不相等，直接将该元素放入到集合中，否则不放入。  
### 有没有可能 2 个不相等的对象有相同的 hashcode。
有可能，最简单的方法，百分百实现的方式就是重写hascode();
### Java 中的 HashSet 内部是如何工作的。
看源码
``` java
public HashSet() {
    map = new HashMap<>();
}
```
默认使用的是HaseMap;

### 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。
序列化是一种用来处理对象流的机制 ,所谓对象流就是将对象的内容进行流化。
序列化是为了解决在对对象流进行读写操作时所引发的问题。
序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流;

### 继承和聚合的区别在哪。
继承：指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识，在设计时一般没有争议性；
聚合：聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；比如计算机与CPU、公司与员工的关系等；表现在代码层面，和关联关系是一致的，只能从语义级别来区分；

# JVM 知识
### 什么情况下会发生栈内存溢出。
a.方法创建了一个很大的对象，如List，Array
b.是否产生了循环调用、死循环
c.是否引用了较大的全局变量
### JVM 的内存结构，Eden 和 Survivor 比例。
JVM内存结构分为两种类型：
线程安全：虚拟机栈、本地方法栈、程序计数器
非线程安全：堆，方法区

虚拟机栈：每个方法被执行时，都会在内存中创建一个空间用来存储方法中的局部变量，方法的出入口等信息。
本地方法栈：每个本地方法被执行时，都会创建一个内存空间，用来存储本地方法中的局部变量，方法的出入口等信息。
程序计数器：是当前程序所执行的class文件的行号指示器，通过改变行号来决定下一段要执行的字节码指令，跳转，循环，异常处理
堆：每一个对象的创建跟分配都是在堆上面进行的，堆分为新生代，老生代。新生代有一个Eden和两个Survivor组成，默认比例是8：2。也可以使用-XXSurvivorRatio来改变百分比。
方法区：用来存放类的版本，类的方法还有static修饰的对象等信息。
###  jvm中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的jvm参数。
![GC流程](http://qiniu.wsxxg.cn/20170428141420806.png)
GC流程图
对象晋升老生代一共有三个可能：
1.当对象达到成年，经历过15次GC（默认15次，可配置），对象就晋升为老生代
2.大的对象会直接在老生代创建
3.新生代跟幸存区内存不足时，对象可能晋升到老生代

jvm参数：
-Xms：初始堆大小
-Xmx：堆最大内存
-Xss：栈内存
-XX:PermSize 初始永久带内存
-XX:MaxPermSize 最大永久带内存
### 你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms，包括原理，流程，优缺点
串行垃圾收集器：收集时间长，停顿时间久
并发垃圾收集器：碎片空间多
CMS:并发标记清除。他的主要步骤有：初始收集，并发标记，重新标记，并发清除（删除），重置
G1：主要步骤：初始标记，并发标记，重新标记，复制清除（整理）

CMS的缺点是对cpu的要求比较高。G1是将内存化成了多块，所有对内段的大小有很大的要求
CMS是清除，所以会存在很多的内存碎片。G1是整理，所以碎片空间较小
 

### 垃圾回收算法的实现原理。

 常用的垃圾回收算法有两种： 引用计数和可达性分析
引用计数是增加一个字段来标识当前的引用次数，引用计数为0的就是可以GC的。但是引用计数不能解决循环引用的问题
可达性分析：就是通过一系列GC ROOT的对象作为起点，向下搜索，搜索所有没有与当前对象GC ROOT 有引用关系的对象。这些对象就是可以GC的。

### 当出现了内存溢出，你怎么排错。
1.首先控制台查看错误日志
2.然后使用jdk自带的jvisualvm工具查看系统的堆栈日志
3.定位出内存溢出的空间：堆，栈还是永久代（jdk8以后不会出现永久代的内存溢出）。
4.如果是堆内存溢出，看是否创建了超大的对象
5.如果是栈内存溢出，看是否创建了超大的对象，或者产生了死循环。
 

### JVM 内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。
重排序：jvm虚拟机允许在不影响代码最终结果的情况下，可以乱序执行。
内存屏障：可以阻挡编译器的优化，也可以阻挡处理器的优化
happens-before原则：
1：一个线程的A操作总是在B之前，那多线程的A操作肯定实在B之前。
2：monitor 再加锁的情况下，持有锁的肯定先执行。
3：volatile修饰的情况下，写先于读发生
4：线程启动在一起之前 strat
5：线程死亡在一切之后 end
6：线程操作在一切线程中断之前
7：一个对象构造函数的结束都该对象的finalizer的开始之前
8：传递性，如果A肯定在B之前，B肯定在C之前，那A肯定是在C之前。
主内存：所有线程共享的内存空间
工作内存：每个线程特有的内存空间


### 简单说说你了解的类加载器。
类加载器主要分为：引导类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader），系统类加载器（App ClassLoader）和自定义加载器（Custom ClassLoader）
双亲委派：双亲委派模式会保证父类加载器先加载类
 

### 讲讲 JAVA 的反射机制。
在运行是，对于任意一个类，都能知道当前类的方法和属性，对于任意一个类，都能调用类的方法和属性，着用动态加载机制就是Java的反射机制。
 
### 你们线上应用的 JVM 参数有哪些。
-XX:PermSize=128M
-XX:MaxPermSize=512m
-XX:PermSize=128M
-XX:MaxPermSize=512m
-Xms512m
-Xmx1024m
-XX:PermSize=640m
-XX:MaxPermSize=1280m
-XX:NewSize=64m
-XX:MaxNewSize=256m
-verbose:gc
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
 

### g1 和 cms 区别,吞吐量优先和响应优先的垃圾收集器选择。
CMS:并发标记清除。他的主要步骤有：初始收集，并发标记，重新标记，并发清除（删除），重置
G1：主要步骤：初始标记，并发标记，重新标记，复制清除（整理）

CMS的缺点是对cpu的要求比较高。G1是将内存化成了多块，所有对内段的大小有很大的要求
CMS是清除，所以会存在很多的内存碎片。G1是整理，所以碎片空间较小
吞吐量优先：G1
响应优先：CMS
###  请解释如下jvm参数的含义： -server -Xms512m -Xmx512m -Xss1024K -XX:PermSize=256m -XX:MaxPermSize=512m -XX:MaxTenuringThreshold=20 XX:CMSInitiatingOccupancyFraction=80 -XX:+UseCMSInitiatingOccupancyOnly。

-server：服务器模式
-Xms512m ：初始堆空间
-Xmx512m：最大堆空间
-Xss1024K ：栈空间
-XX:PermSize=256m ：初始永久带空间
-XX:MaxPermSize=512m ：最大永久带空间
-XX:MaxTenuringThreshold=20 ：对象的生命周期
XX:CMSInitiatingOccupancyFraction=80 ：老年代的内存在使用到70%的时候，就开始启动CMS了
-XX:+UseCMSInitiatingOccupancyOnly：它就只会按照你设置的比率来启动CMS GC了

# 开源框架知识
### 简单讲讲 tomcat 结构，以及其类加载器流程。

 

### tomcat 如何调优，涉及哪些参数。

 

### 讲讲 spring 加载流程。

 

### 讲讲 Spring 事务的传播属性。

PROPAGATION_REQUIRED--支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。


### Spring 如何管理事务的。

# 操作系统

### Linux 系统下你关注过哪些内核参数，说说你知道的。

 

### linux 下 IO 模型有几种，各自的含义是什么。

 

### epoll 和 poll 有什么区别。

 

### 平时用到哪些 Linux 命令。

 

### 用一行命令查看文件的最后五行。
输出test文件的后五行：  
   
liyi@liyi:~/Desktop > tail -n 5 test  
   
输出test文件的前五行：  
   
liyi@liyi:~/Desktop > head -n 5 test  

### 用一行命令输出正在运行的 java 进程。

 

### 介绍下你理解的操作系统中线程切换过程。

 

### 进程和线程的区别。

# 多线程
### 多线程的几种实现方式，什么是线程安全。

 

### volatile 的原理，作用，能代替锁么。

 

### 画一个线程的生命周期状态图。

 

### sleep 和 wait 的区别。

 

### Lock 与 Synchronized 的区别。

 

### synchronized 的原理是什么，解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。

 

### 用过哪些原子类，他们的原理是什么。

 

### 用过线程池吗，newCache 和 newFixed 有什么区别，他们的原理简单概括下，构造函数的各个参数的含义是什么，比如 coreSize，maxsize 等。



### 线程池的关闭方式有几种，各自的区别是什么。

 

### 假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有 10 个线程同时调用它，如何做到。

 

### spring 的 controller 是单例还是多例，怎么保证并发的安全。

### ThreadLocal 用过么，用途是什么，原理是什么，用的时候要注意什么。

 

### 如果让你实现一个并发安全的链表，你会怎么做。

 

### 有哪些无锁数据结构，他们实现的原理是什么。

 

### 讲讲 java 同步机制的 wait 和 notify。

 

### 多线程如果线程挂住了怎么办。

 

### countdowlatch 和 cyclicbarrier的内部原理和用法，以及相互之间的差别。

 

### 使用 synchronized 修饰静态方法和非静态方法有什么区别。


### 简述 ConcurrentLinkedQueue 和 LinkedBlockingQueue 的用处和不同之处。

 

### 导致线程死锁的原因？怎么解除线程死锁。

 

### 非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。



### 正确使用 Volatile 变量

# TCP 与 HTTP

### http1.0 和 http1.1 有什么区别。

 

### TCP 三次握手和四次挥手的流程，为什么断开连接要 4次,如果握手只有两次，会出现什么。

 

### TIME_WAIT 和 CLOSE_WAIT 的区别。

 

### 说说你知道的几种 HTTP 响应码，比如 200, 302, 404。

 

### 当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。

 

### TCP/IP 如何保证可靠性，说说 TCP 头的结构。

 

### 如何避免浏览器缓存。

 

### 简述 Http 请求 get 和 post 的区别以及数据包格式。

 

### 简述 HTTP 请求的报文格式。

###  HTTPS 的加密方式是什么，讲讲整个加密解密流程。


# 架构设计与分布式

 

1. 常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的。

 

2. 用 java 自己实现一个 LRU。

 

3. 分布式集群下如何做到唯一序列号。

 

4. 设计一个秒杀系统，30 分钟没付款就自动关闭交易。

 

5. 如何使用 Redis 和 zookeeper 实现分布式锁？有什么区别优缺点，分别适用什么场景。

 

6. 如果有人恶意创建非法连接，怎么解决。

 

7. 分布式事务的原理，优缺点，如何使用分布式事务。

 

8. 什么是一致性 hash。

 

9. 什么是 restful，讲讲你理解的 restful。

 

10. 如何设计建立和保持 100w 的长连接。

 

11. 如何防止缓存雪崩。

 

12. 解释什么是 MESI 协议(缓存一致性)。

 

13. 说说你知道的几种 HASH 算法，简单的也可以。

 

14. 什么是 paxos 算法。

 

15. 什么是 zab 协议。

 

16. 一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新。

 

17. 线上系统突然变得异常缓慢，你如何查找问题。


18. 说说你平时用到的设计模式。 


19. Dubbo 的原理，数据怎么流转的，怎么实现集群，负载均衡，服务注册和发现。重试转发，快速失败的策略是怎样的。

 

20. 一次 RPC 请求的流程是什么。

 

21. 异步模式的用途和意义。

 

22. 缓存数据过期后的更新如何设计。

 

23. 编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。

 

24. 设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。画一下架构图。

 

25. MVC 模式，即常见的 MVC 框架。

 

26. 聊了下曾经参与设计的服务器架构。

 

27. 应用服务器怎么监控性能，各种方式的区别。

 

28. 如何设计一套高并发支付方案，架构如何设计。

 

29. 如何实现负载均衡，有哪些算法可以实现。

 

30. Zookeeper 的用途，选举的原理是什么。

 

### Mybatis 的底层实现原理。
MyBatis底层就是JDBC   所以他的核心就是配置文件  ：  
   
      1：全局配置文件 （配置数据源 事务运行时信息）  
      2：映射文件（执行statement的相关信息，包括SQL语句，输入参数，输出结果）  
      MyBatis把全局配置文件加载到内容中 构建出SqlSessionFactory    ，这个工厂的作用相当于生产对象生产SqlSession。  
     SqlSession   ：它是一个面向程序员的接口，可以操作数据库。 接口有一个默认实现DefaultSqlSession。  
在SqlSession   中有一个executor 执行器。  SqlSession   本身不能操作数据库 需要通过这个执行器去操作。有2个实现 一个叫做基本执行器，还有一个缓存执行器  
（默认）。 MappedStatement:封装了执行Statement信息，包括SQL语句 输入参数，输出结果。由它去操作数据库。  
   
输入输出参数类型：  
            1：基本类型  
            2：自定义类型  
            3：hashmap  
   
根据源码：看到Sqlsession内部并不能直接操作数据库。而是利用内部的一个执行器去操作数据库。执行器执行的时候会去执行MappedStatement   
到最后才去真正执行数据库。  

请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。

 

### 请思考一个方案，实现分布式环境下的 countDownLatch。

 

### 后台系统怎么防止请求重复提交。

 

### 如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点。本地缓存在并发使用时的注意事项。

 

### 描述一个服务从发布到被消费的详细过程。

 

### 讲讲你理解的服务治理。

 

### 如何做到接口的幂等性。

### redis和memcached的区别

1、Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等；  
2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；  
3、虚拟内存--Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘；  
4、过期策略--memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10；  
5、分布式--设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从；  
6、存储数据安全--memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）；  
7、灾难恢复--memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；  
8、Redis支持数据的备份，即master-slave模式的数据备份；  
9、应用场景不一样：Redis出来作为NoSQL数据库使用外，还能用做消息队列、数据堆栈和数据缓存等；Memcached适合于缓存SQL语句、数据集、用户临时性数据、延迟查询数据和session等。  

## 算法
### 10 亿个数字里里面找最小的 10 个。

 

### 有 1 亿个数字，其中有 2 个是重复的，快速找到它，时间和空间要最优。

 

### 2 亿个随机生成的无序整数,找出中间大小的值。

 

### 给一个不知道长度的（可能很大）输入字符串，设计一种方案，将重复的字符排重。

 

### 遍历二叉树。

 

### 有 3n+1 个数字，其中 3n 个中是重复的，只有 1 个是不重复的，怎么找出来。

 

### 写一个字符串反转函数。

 

### 常用的排序算法，快排，归并、冒泡。 快排的最优时间复杂度，最差复杂度。冒泡排序的优化方案。

 

### 二分查找的时间复杂度，优势。

 

### 一个已经构建好的 TreeSet，怎么完成倒排序。

 

### 什么是 B+树，B-树，列出实际的使用场景。

### SQL

删除mysql数据库中名称重复的数据并保留id为最小的1条

DELETE FROM people WHERE id NOT IN (SELECT minid FROM (SELECT MIN(id) AS minid FROM people GROUP BY name) b);


### 行转列

###  MySQL存储引擎－ MyISAM与InnoDB区别

InnoDB和MyISAM是许多人在使用MySQL时最常用的两个表类型，这两个表类型各有优劣，视具体应用而定。基本的差别为：MyISAM类型不支持事务处理等高级处理，  
而InnoDB类型支持。MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。  
   
两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁。而MyISAM不支持.所以MyISAM往往就容易被人认为只适合在小项目中使用  